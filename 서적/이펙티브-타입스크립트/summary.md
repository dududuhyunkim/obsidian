# 이펙티브 타입스크립트

## 옮긴이의 글
> 과거에는 브라우저에서 가벼운 처리를 위해 도입한 단일 스레드와 비동기 모델이 단점으로 지적되어 왔지만, 현대의 멀티코어 병렬 프로그래밍 환경에는 적합한 메커니즘으로 인식되는 역설적인 상황이 벌어지고 있습니다.

=> 정말 그러한가?

1. 단일 스레드와 비동기 모델의 단점은 무엇인가?
  - 단일 스레드는 한번에 하나의 작업만을 처리할 수 있기 때문에, CPU 집중적인 작업이나 긴 실행 시간을 필요로하는 작업들이 다른 작업들을 차단하여 성능 병목을 일으킬 수 있다.
  - 단일 스레드로 인해 멀티 코어 CPU를 최대한 활용하지 못할 수 있다.
  - 예
    - Python
      - 주로 단일 스레드를 사용하며, `asyncio` 모듈을 통해 비동기 프로그래밍을 지원한다. ES6 와 마찬가지로 `async`, `await` 키워드를 사용하여 비동기 처리를 할 수 있다.
    - Ruby
      - 단일 스레드 기반으로 동작하며, `EventMachine`, `async` 라이브러리를 활용하여 비동기적인 작업을 처리할 수 있다. 
    - C/C++
      - 기본적으로 멀티 스레드를 지원하지만, 비동기 프로그래밍을 위한 고수준의 추상화를 제공하지는 않는다.
    - Java
      - 스레드를 직접 다루거나 멀티 스레드를 지원하는 고수준의 도구를 사용하여 병렬 처리를 할 수 있다. 비동기 프로그래밍을 위한 다른 라이브러리를 이용할 수 있다.
    - Php
      - 일반적으로 단일 스레드로 동작하며, 이벤트 루프나 멀티스레드를 기본적으로 지원하지 않는다. 비동기 프로그래밍을 위한 라이브러리를 이용할 수 있다.
  - 비동기 모델은 callback hell 이 발생할 수 있으며 코드의 복잡성을 야기할 수 있다.

2. 현대의 멀티코어 병렬 프로그래밍 환경에서는 어떤 점 때문에 적합한 메커니즘으로 인식되는가?
  - 비동기 프로그래밍은 I/O 바운드 작업(네트워크 요청, 파일 시스템 액세스 등)에서 매우 효과적이다. 멀티 코어 환경에서도 비동기 프로그래밍은 CPU의 대기시간을 최소화하고 CPU 자원을 효율적으로 활용할 수 있다.
  - 싱글 스레드는 멀티 코어 환경에서 장점을 발휘할 수 없으나, 비동기 프로그래밍으로 인해, OS 커널과 libuv 스레드와 같은 외부 환경에서 병렬로 처리될 수 있으므로 멀티 코어 환경의 장점을 누릴 수 있다.


[concept]
- 실행되고 있는 프로그램 자체를 프로세스라 한다.
- 프로세스 내에서 할당 받은 실행단위를 스레드라 한다.
  - 스레드는 프로세스 내의 메모리 공간을 공유한다.
  - 각각의 프로세스는 별도의 메모리 공간을 갖는다.

- 자바스크립트는 비동기적으로 동작하는 코드를 작성하기에 용이하다. 

- 멀티코어 CPU 는 여러 CPU를 사용하므로 실제로 여러 작업을 동시에 처리할 수 있다.
- 단일 스레드에서는 한번에 하나의 작업만 처리할 수 있는 방식으로 여러 작업을 처리하기 어렵다.

- nodejs는 Chrome V8 Javascript 엔진으로 빌드된 javascript 런타임 환경이다.
  - 단일 스레드, 비동기 이벤트 기반, 논 블로킹 I/O
  - 콜스택, 백그라운드, 이벤트 큐, 이벤트 루프
    - 호출 되는 함수가 콜스택에 쌓인다.
    - 비동기 작업이 백그라운드내에서 실행되고, 완료되면 이벤트 큐로 전달된다.
      - 콜백 함수는 블로킹을 방지하며, nodejs 내에서 논블로킹으로 동작하게 한다.
      - 백그라운드는 libuv 스레드 풀 혹은 OS 커널을 의미한다.
    - 이벤트 루프는 콜스택이 비어있을 때, 이벤트 큐에서 콜백 함수를 꺼내서 콜 스택으로 옮겨 실행한다.

- Nodejs 환경에서는 멀티코어 CPU를 최대한 활용하기 위해 여러 방식을 활용할 수 있다.
  - 클러스터링
    - 여러개의 Nodejs 프로세스를 만들어 각각 다른 CPU 코어에 할당하여 병렬로 여러 요청을 처리할 수 있게 하며, 각각의 프로세스가 독립적으로 동작하며, 로드 밸런싱을 통해 요청을 분산시킴으로써 전체적인 성능을 향상시킬 수 있다.
    - 인스턴스 수를 늘려 Scale out 하는 것과는 별개로 단일 인스턴스의 내부 최적화 기법이다.
  - 워커 스레드
    - nodejs 내에서 멀티스레딩을 지원하는 방법으로, 단일 스레드 내에서 병렬 처리를 할 수 있게 한다. 
    - nodejs 는 비동기 기반의 모델을 가지고 있고, 주로 이를 활용하여 비동기 작업을 처리하고 성능을 극대화한다.
  - 서버리스 아키텍처
    - 서버의 인프라를 추상화하고 관리를 단순화하는 방식, 애플리케이션을 위한 인프라를 관리하는 것을 개발자가 아닌 클라우드 제공업체에게 위임하여 개발자가 코드에 집중할 수 있도록 돕는다.
    - 서버리스 아키텍쳐는 이벤트 기반으로 동작한다. 이벤트가 발생하면 트리거가 작동되어 함수 또는 서비스가 실행된다.
    - aws lambda 는 컨테이너 기반으로 동작한다. 이벤트 발생할 때마다 컨테이너 내에서 실행된다.
    - nodejs와 특성이 유사하다.
      - 단일 스레드와 비동기성
      - 이벤트 기반 아키텍쳐
      - scaling



=> 정말 그렇다.

1. javascript의 runtime 인 nodejs 는 싱글 스레드, 비동기 모델로 동작한다.
2. 싱글 스레드는 한번에 하나의 작업 밖에 실행할 수 없는 제한이 있다.
3. 하지만 nodejs는 비동기 모델을 통해, I/O 바운드 작업(네트워크 요청, 파일 시스템 액세스 등)들이 외부 환경(OS 커널, libuv 스레드 풀)에서 작동된다.
4. 그렇기 때문에, 멀티 코어 환경에서 비동기 작업들을 병렬적으로 처리할 수 있어 효율적이다.
5. 따라서, nodejs는 단일 스레드와 비동기 모델이 단점으로 지적되어 왔지만, 현대의 멀티코어 병렬 프로그래밍 환경에는 적합한 메커니즘으로 인식될 수 있다.

[furthermore]
- 논리적으로는 이해가 되었으나, 멀티 코어 환경에서 실제로 I/O 바운드 작업들이 여러 CPU 들에 의해 사용되는지 확인하고 싶다.
  - 단일 코어와 멀티 코어 의 성능 비교를 해보고 싶다.
  - 웹서버 practice에서 해당 사항이 구체적으로 어떤 도움이 될지 궁금하다.
- 동시성 문제에 대해 좀 더 딥다이브 해봐야한다.

## 1장 타입스크립트 알아보기
### [아이템 1] 타입스크립트와 자바스크립트의 관계 이해하기
- 타입스크립트는 자바스크립트의 superset 이다.
- 타입스크립트는 자바스크립트의 런타임 동작을 모델링하는 타입 시스템을 가진다. 이로 인해 런타임 오류를 발생시키는 코드를 다소 예방할 수 있다.
- 타입스크립트 타입 시스템은 전반적으로 자바스크립트 동작을 모델링한다.
  - 자바스크립트에서 동작하지만, 타입스크립트에서는 동작하지 않는 경우가 있다.

### [아이템 2] 타입스크립트 설정 이해하기
- noImplicitAny 설정은 변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어한다.
  - noImplicitAny 설정 해제는 자바스크립트로 되어있는 기존 프로젝트를 마이그레이션하는 상황에서 유효하다.
- strickNullChecks 설정은 null과 undefine가 모든 타입에서 허용되는지 확인하는 설정이다.
  - null과 undefined 관련한 오류를 잡아 내는 데 많은 도움이 되지만, 코드 작성을 어렵게한다.

### [아이템 3] 코드 생성과 타입이 관계없음을 이해하기
- 타입스크립트 컴파일러는 2가지 역할을 수행한다.
  - 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일링 한다.
  - 코드의 타입 오류를 체크한다.

> 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일링 한다.

=> 구체적으로 최신과 구버전이 의미하는 것을 정확히 알고 있는가?

[concept]
- ECMAScript는 JavaScript 언어의 표준 사양을 정의하는 규격이다.
  - Javascript는 Netscape에서 처음 개발되었고, Microsoft에서 JScript 라는 이름으로 구현하여 확산되었다. 브라우저 간의 표준화와 호환성을 위해 이를 통합하는 표준이 필요했고, 이것이 ECMAScript 이다.
- typescript compiler가 최신 버전의 ECMAScript를 따른 javascript, typescript를 구버전의 Javascript 로 트랜스파일링 한다.

- 각 브라우저에서 자바스크립트의 구버전을 지원하는 정도가 다르다.
  - 예
    - IE(Internet Explorer)는 최신의 ECMAScript 표준을 완전히 지원하지 않는 경우가 많았다.
    - Safari의 특정 버전은 최신의 ECMAScript 표준을 지원하지 않은 경우가 있었다.
    - ...
- 브라우저마다 특정 자바스크립트 기능을 지원하는 정도가 다르기 때문에 크로스 브라우징이 필요하다. polyfill 과 같은 기술을 사용하여 지원하지 않는 기능을 대체할 수도 있다.
  - 크로스 브라우징 은 웹사이트나 웹 애플리케이션이 여러 브라우저와 기기에서 일관되게 동작하도록 하는 것을 의미한다.
    - HTML, CSS, JavaScript 호환성
      - 예
        - CSS box model : 특히 `box-sizing` 속성을 사용할 때, 일부 브라우저에서는 내부 컨텐츠를 포함한 전체 요소의 크기를 계산하는 방식이 다를수 있다.
          - CSS Reset 이나 Normalize.css 를 사용하여 브라우저간 차이를 최소화 할 수 있다.
        - javascript event handler : 특정 자바스크립트 이벤트 핸들러를 등록할 때, 이벤트 버블링과 캡처링의 동작 방식이 브라우저마다 조금씩 다를 수 있다.
          - 이벤트 버블링 : 이벤트가 발생한 요소에서 시작하여 상위 요소로 이벤트가 전파되는 것을 의미한다.
          - 이벤트 캡처링 : 버블링과 반대 개념으로 최상위 요소(document 또는 body)에서 시작하여 이벤트가 발생한 요소로 전파되는 것을 의미한다.
          - 이벤트 버블링과 캡처링은 이벤트가 DOM 트리를 따라 상위 또는 하위 요소로 전파되는 방식을 설명하며, 브라우저들은 이러한 이벤트 전파 방식이 다르게 지원할 수 있다.
            - 기본적으로 W3C에 의해 정의된 표준에 따라 동작한다. 브라우저의 엔진 개발자들은 그 표준을 구현하는 구현체가 다르게 구현될 수 있다.
            - 대부분의 브라우저는 이벤트 버블링을 기본적으로 지원하며, 캡처링은 버블링 전에 발생한다.
            - 이벤트 버블링과 캡처링을 명시적으로 다뤄야 하는 것이 드물수 있으나 아래와 같은 상황에 유용할 수 있다.
              - 이벤트 위임 (Event Delegation) : 부모 요소에 이벤트를 등록하고, 자식 요소에서 발생한 이벤트를 부모에서 처리할 때 유용하다. 이벤트 버블링을 이용하여 특정 자식 요소에 대한 개별 이벤트 핸들러를 등록하는 대신 부모 요소에서 이벤트를 캐치하여 처리할 수 있다. 이렇게 하면 동적으로 추가되는 요소들에 대해서도 한 곳에서 이벤트 관리할 수 있어 유지보수성이 높아진다.
              - 이벤트 중단 (Stop Propagation) : 이벤트 버블링이나 캡처링을 활용하여 특정 이벤트가 상위로 전파되지 않도록 중단할 수 있습니다. 예를 들어, 특정 요소에서 이벤트가 발생했을 때 상위로 이벤트가 전파되지 않도록 막을 수 있습니다.
              - ...
        - font rendering : 폰트 렌더링방식 혹은 앤티앨리어싱 방식이 다를 수 있다.
          - 웹 폰트를 사용하는 것이 도움이 된다.
          - font stack 을 사용하여, fallback 할 수 있도록 한다.
        - ...
    - 브라우저 테스트
    - polyfill 사용
      - Polyfill은 새로운 기능을 지원하지 않는 이전 버전의 브라우저에서 해당 기능을 구현하기 위한 코드 조각이다.
        - 예를 들어 `Array.prototype.includes` 메서드는 ES7(ES2016)에 도입되었고, 이를 지원하지 않는 브라우저에서도 이를 사용하기 위해서 polyfill를 작성하여 사용할 수 있도록 한다.
          - `<head>`, `<body>` 안에서 다른 js 코드가 실행되기 전에 먼저 로드되도록하는 것이 좋다.
          - 이미 지원하는 경우에는 polyfill 의 내부 구현체가 실행되지 않도록 작성해야한다.
    - 웹 표준 준수
      - HTML, CSS, JS 의 표준을 준수하여 크로스 브라우징에 도움이 된다.

- webkit은 웹 브라우저 엔진 중 하나로 웹 페이지를 해석하고 표시하는 역할을 한다.
  - Apple의 safari 웹 브라우저를 위해 개발되었으며, 현재에도 여러 브라우저에서 사용되고 있다.
  - 최근에는 Chromium을 기반으로하는 브라우저가 늘어나면서 Blink 라는 렌더링 엔진을 사용하는 Chrome, Edge 등이 있다.
    - 예전에는 각 브라우저 제조사가 자체적으로 브라우저 엔진을 개발하여 사용했는데, 그로 인해 브라우저 간의 렌더링 차이가 상당했다. 그러나 [[Chromium project]] 가 등장하면서, 여러 브라우저 제조사들이 Chromium 기반으로 브라우저를 개발하는 추세가 생겼다.

[furthermore]
- javascript event handler 에 대해 deep dive 가 필요하다.
  - 기본적으로 이벤트 헨들러를 등록할 때, 부모 자식 간의 전파에 대해 고민한 적이 없다.
  - 기본적으로 버블링 설정이 되어 있어, 상위 부모로 이벤트가 전달 되는 것이 었고, 캡쳐링을 고려한 적이 없다.
  - 예시를 들어 정리해두면 좋을 것 같다.
- 인터프리터, 컴파일러, 트랜스파일러 등 용어에 대해 deep dive 가 필요하다.
  - 개발하는데 크게 문제가 되지 않으나 기반을 잡아놓자.